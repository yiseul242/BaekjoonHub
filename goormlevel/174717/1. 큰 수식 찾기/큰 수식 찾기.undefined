				
		}

		// 최종 계산 결과 반환
		return numStack.pop();
	}

	private static boolean isOperator(String str) {
		if (str.equals("*") || str.equals("+") || str.equals("-")) {
			return true;
		}
		return false;
	}

	// 중위 표기법 -> 후위 표기법으로 변환
	private static String toPostfix(String expression) {
		StringBuilder output = new StringBuilder();
		Stack<Character> operatorStack = new Stack<>();
		StringBuilder number = new StringBuilder(); // 숫자를 임시 저장할 문자열

		for (int i = 0; i < expression.length(); i++) {
			char curr = expression.charAt(i);

			if (Character.isDigit(curr)) {
				// 숫자는 후위 표기법에 추가 (여러 자리 숫자 처리)
				number.append(curr);
			} else {
				// 숫자가 끝났으면 후위 표기법에 추가
				if (number.length() > 0) {
					output.append(number.toString()).append(" "); // 후위 표기법에 숫자와 공백 추가
					number.setLength(0); // 숫자 초기화
				}

				// 연산자 스택에 현재 연산자보다 우선순위가 큰 연산자가 있으면 후위 표기법에 추가
				while (!operatorStack.isEmpty() && precedence(operatorStack.peek()) >= precedence(curr)) {
					output.append(operatorStack.pop()).append(" ");
				}
				operatorStack.push(curr);
				
			}
			
		}

		// 마지막 숫자 처리
		if (number.length() > 0) {
			output.append(number.toString()).append(" ");
		}
	
		// 스택에 남아있는 연산자 처리
		while (!operatorStack.isEmpty()) {
			output.append(operatorStack.pop()).append(" ");
		}

		return output.toString().trim();
}

	// 연산자의 우선순위 반환
	private static int precedence(char operator) {
		// 연산자는 +, *, - 기호로만 이루어짐
		if (operator == '*') {
			return 1;
		} else { // +, - 연산자인 경우
			return 0;
		}
	}
}